<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://yourdomain.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yourdomain.com/" rel="alternate" type="text/html" /><updated>2024-05-24T23:33:59+00:00</updated><id>http://yourdomain.com/feed.xml</id><title type="html">Your Site Title</title><subtitle>This is an example site description. You can use Markdown here.</subtitle><entry><title type="html">CSS: layout of the header</title><link href="http://yourdomain.com/2024/05/22/css-flex-layout.html" rel="alternate" type="text/html" title="CSS: layout of the header" /><published>2024-05-22T16:24:00+00:00</published><updated>2024-05-22T16:24:00+00:00</updated><id>http://yourdomain.com/2024/05/22/css-flex-layout</id><content type="html" xml:base="http://yourdomain.com/2024/05/22/css-flex-layout.html"><![CDATA[<p>The final result can refer to the header banner of this page. ⬆️</p>

<h2 id="the-originals">the Originals</h2>

<p><img src="/assets/img/nyc-guidelines.jpg" alt="NYC MTA design guideline" /></p>

<h2 id="the-header">the Header</h2>

<p><img src="/assets/img/header.png" alt="header banner" /></p>

<h3 id="components">Components</h3>

<h4 id="brand">Brand</h4>

<h4 id="post-title">Post title</h4>

<h4 id="navigations">Navigations</h4>

<h2 id="responsive-layout">Responsive layout</h2>

<p>Using the grid system from Bootstrap, the header can adapt to different window/screen size by arranging its components  .</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">sm</code></li>
</ul>

<p>Using media queries <code class="language-plaintext highlighter-rouge">@media</code> to manually add some style based on the width of the viewport.</p>

<h2 id="display-flex"><code class="language-plaintext highlighter-rouge">display: flex</code></h2>]]></content><author><name>jianing</name></author><category term="web" /><category term="css" /><summary type="html"><![CDATA[The final result can refer to the header banner of this page. ⬆️]]></summary></entry><entry><title type="html">1. Shellcode Development</title><link href="http://yourdomain.com/2023/01/17/shellcode-development.html" rel="alternate" type="text/html" title="1. Shellcode Development" /><published>2023-01-17T12:00:00+00:00</published><updated>2023-01-17T12:00:00+00:00</updated><id>http://yourdomain.com/2023/01/17/shellcode-development</id><content type="html" xml:base="http://yourdomain.com/2023/01/17/shellcode-development.html"><![CDATA[<h3 id="1-printing-on-the-screen">1. Printing on the Screen</h3>

<p>Program using Relative Addressing technique</p>

<p><code class="language-plaintext highlighter-rouge">src/task1/print_rel.asm</code></p>

<pre><code class="language-assembly">[SECTION .text]
global _start
_start:
        jmp saveme			; (complete)	jump to the call instruction that right
        								;							before the "Hello, world!" string
shellcode:
				pop esi					; (complete)	pop the top value of stack (address of
												;							msg) and save to esi register
												
        mov eax, 4  		; (complete)	opcode for write system call
        mov ebx, 1  		; (complete)	1st arg is the fd (1 = STDOUT)
        mov ecx, esi  	; (complete)	2nd arg is the string address
        mov edx, 15   	; 3rd arg is len
        int 0x80      	; system call interrupt

        mov eax, 1    	; opcode for exit system call
        mov ebx, 0    	; 1st arg, exit(0)
        int 0x80      	; system call interrupt
 saveme:
        call shellcode	; (complete)	jump back to the 1st instruction after jmp
        								;							instruction, and save the address of 
        								;							msg on the top of stack
        msg db "Hello, world!", 0xA, 0xD
</code></pre>

<p><img src="/assets/screenshots/1-1-rel.png" alt="1-1-rel" /></p>

<p>Program using Stack methods</p>

<p><code class="language-plaintext highlighter-rouge">src/task1/print_stk.asm</code></p>

<pre><code class="language-assembly">[SECTION .text]
global _start
_start:
        mov eax, 0
        push eax
        push 0x000a0d21	; hex format of "!\r\n\0"
        push "orld"
        push "o, w"			; (complete)	push "o, w" to stack
        push "Hell"			; (complete)	push "Hell" to stack

        mov eax, 4			; (complete)	opcode for write system call
        mov ebx, 1			; (complete)	1st arg is the fd (1 = STDOUT)
        mov ecx, esp		; (complete)	2nd arg is the string address (stack top)
				mov edx, 15			; 3rd arg, len
        int 0x80				; system call interrupt

        mov eax, 1			; opcode for exit system call
        mov ebx, 0			; 1st arg, exit(0)
        int 0x80				; system call interrupt
</code></pre>

<p><img src="/assets/screenshots/1-2-stk.png" alt="1-2-stk" /></p>

<blockquote>
  <p><em>(a) In <code class="language-plaintext highlighter-rouge">print_stk.asm</code>, explain how the line “<code class="language-plaintext highlighter-rouge">push 0x000a0d21</code>” works. Show a screenshot from gdb to support your explanation.</em></p>
</blockquote>

<p>From the gdb disassembler, the line <code class="language-plaintext highlighter-rouge">push 0x000a0d21</code> is located in memory at <code class="language-plaintext highlighter-rouge">0x08048066</code>.</p>

<p><img src="/assets/screenshots/1-1-1-disassembler.png" alt="1-1-1-disassembler" /></p>

<p>I set a breakpoint at <code class="language-plaintext highlighter-rouge">_start</code> and used <code class="language-plaintext highlighter-rouge">si</code> command to execute one instruction each time. When the program is running before executing the instruction of <code class="language-plaintext highlighter-rouge">push 0x000a0d21</code>, from the status of all registers,</p>

<p><img src="/assets/screenshots/1-1-2-registers-before.png" alt="1-1-2-registers-before" /></p>

<p>we can see that the current stack top address in memory is <code class="language-plaintext highlighter-rouge">0xbffff5fc</code>, and the value inside is <code class="language-plaintext highlighter-rouge">0x0</code>.</p>

<p>Then, after running the <code class="language-plaintext highlighter-rouge">push 0x000a0d21</code> instruction. From the register info, we can see that the value <code class="language-plaintext highlighter-rouge">0x000a0d21</code> is pushed into stack and the value of register <code class="language-plaintext highlighter-rouge">esp</code> has changed to <code class="language-plaintext highlighter-rouge">0xbffff5f8</code> (deduced 4), pointing to address of the top of stack.</p>

<p><img src="/assets/screenshots/1-1-3-registers-after.png" alt="1-1-3-registers-after" /></p>

<blockquote>
  <p><em>(b) Also, in the same file, explain how you got the string address. Show a screenshot from gdb to support your explanation.</em></p>
</blockquote>

<p>I used instruction <code class="language-plaintext highlighter-rouge">mov ecx, esp</code> to get the string address where it sets <code class="language-plaintext highlighter-rouge">ecx</code> register to the value inside <code class="language-plaintext highlighter-rouge">esp</code>. The <code class="language-plaintext highlighter-rouge">esp</code> register keeps the address of the stack top which points to one segment of the string <code class="language-plaintext highlighter-rouge">Hello, world!\r\n</code>.</p>

<p>By executing instructions one by one, from gdb, we can see that after <code class="language-plaintext highlighter-rouge">mov ecx, esp</code> is executed, the <code class="language-plaintext highlighter-rouge">ecx</code> register holds the address points to the string. Then, the system call <code class="language-plaintext highlighter-rouge">write</code> can use the string address as second argument.</p>

<p><img src="/assets/screenshots/1-2-1-register-after.png" alt="1-2-1-register-after" /></p>

<hr />

<h3 id="2-spawning-a-shell">2. Spawning a Shell</h3>

<h4 id="21-startup-code-labshasm">2.1 Startup Code (labsh.asm)</h4>

<blockquote>
  <ol>
    <li><em>The process number of both the calling shell and the spawned shell using “<code class="language-plaintext highlighter-rouge">echo $$</code>”.</em></li>
  </ol>
</blockquote>

<p><img src="/assets/screenshots/2-1-1.png" alt="2-1-1" /></p>

<blockquote>
  <ol>
    <li><em>The passed environment variables to the spawned shell using “<code class="language-plaintext highlighter-rouge">/usr/bin/env</code>”</em></li>
  </ol>
</blockquote>

<p><img src="/assets/screenshots/2-1-2-usr-bin-env.png" alt="2-1-2-usr-bin-env" /></p>

<h4 id="22-providing-arguments-to-binsh">2.2 Providing Arguments to <code class="language-plaintext highlighter-rouge">/bin/sh</code></h4>

<p>I constructed the argument string “<code class="language-plaintext highlighter-rouge">-c</code>” and “<code class="language-plaintext highlighter-rouge">ls -la</code>” by pushing them into stack and use <code class="language-plaintext highlighter-rouge">esi</code> register to keep their address in memory. When constructing <code class="language-plaintext highlighter-rouge">argv</code>, I pushed the address of each argument string into the stack to form an array of strings.</p>

<p><code class="language-plaintext highlighter-rouge">src/task2/labsh_args.asm</code></p>

<pre><code class="language-assembly">section .text
  global _start
    _start:
      mov  eax, 0
      push eax          ; Use 0 to terminate the string
      push "//sh"
      push "/bin"
      mov  ebx, esp     ; Get the string address of "/bin//sh"

      ; push "-c" and "ls -la" into stack
      push eax
      push "-c"
      push eax
      push "la"
      push "ls -"
      mov esi, esp			; Keep the current stack top address to esi register
      
      ; Construct the argument array argv[]
      push eax					; argv[3] = 0, EOL
      push esi					; argv[2] points to "ls -la"
      add esi, 12				; move the esi register to point to "-c"
      push esi					; argv[1] points to "-c"
      add esi, 20				; move the esi register to point to "/bin//sh"
      push esi					; argv[0] points to "/bin//sh"
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      mov edx, 0     		; No env variables 

      ; Call execve()
      mov  eax, 0     	; eax = 0x00000000
      mov  al, 0x0b    	; eax = 0x0000000b
      int  0x80
</code></pre>

<p><img src="/assets/screenshots/2-2-1-result.png" alt="2-2-1-result" /></p>

<h4 id="23-providing-env-variable-to-binsh">2.3 Providing Env. Variable to <code class="language-plaintext highlighter-rouge">/bin/sh</code></h4>

<p>I constructed environment variable strings by pushing them into stack and use <code class="language-plaintext highlighter-rouge">esi</code> register to keep their address in memory as in the 2.2. When constructing <code class="language-plaintext highlighter-rouge">envp</code>, I pushed the address of each envrionment variable string into the stack to form an array of strings.</p>

<p><code class="language-plaintext highlighter-rouge">src/task2/labsh_env.asm</code></p>

<pre><code class="language-assembly">section .text
  global _start
    _start:
      ; Store the argument string on stack
      mov  	eax, 0
      push 	eax					; Use 0 to terminate the string
      push 	"//sh"
      push 	"/bin"
      mov  	ebx, esp		; Get the string address

			; Construct the argument array argv[] = { NULL }
      mov 	ecx, eax
 			
			; Construct the envrionment variable strings
      push 	eax
      push 	"4"
      push 	"=123"
      push 	"aaaa"
      push 	eax
      push 	"8"
      push 	"=567"
      push 	"bbbb"
      push 	eax
      push 	"4"
      push 	"=123"
      push 	"cccc"
      mov 	esi, esp	; Save the address of stack top to esi
      
      ; Construct the environment array envp[]
      push 	eax				; envp[3] = 0, EOL
      push 	esi				; envp[2] points to "cccc=1234"
      add 	esi, 16 	; move the esi to point to next string
      push 	esi				; envp[1] points to "bbbb=5678"
      add 	esi, 16 	; move the esi to point to next string
      push 	esi				; envp[0] points to "aaaa=1234"
      mov  	edx, esp	; Get the address of envp[]

      ; Call execve()
      mov  	eax, 0		; eax = 0x00000000
      mov  	al, 0x0b	; eax = 0x0000000b
      int  	0x80
</code></pre>

<p><img src="/assets/screenshots/2-3-1-result.png" alt="2-3-1-result" /></p>

<h4 id="24-using-the-relative-addressing-technique">2.4 Using the Relative Addressing Technique</h4>

<p>First, the program jumps to a <code class="language-plaintext highlighter-rouge">call</code> instruction at line 19, right before the the string.</p>

<p><img src="/assets/screenshots/2-4-2-start.png" alt="2-4-2-start" /></p>

<p>Then, the program executes the <code class="language-plaintext highlighter-rouge">call</code> instruction and jumps back to the instruction after the previous <code class="language-plaintext highlighter-rouge">jmp</code> instruction, and push the address of the string <code class="language-plaintext highlighter-rouge">/bin/sh*AAAABBBB</code> into stack.</p>

<p><img src="/assets/screenshots/2-4-3-one.png" alt="2-4-3-one" /></p>

<p>Now, The stack top contains the address of the string:</p>

<p><img src="/assets/screenshots/2-4-4-stack-top.png" alt="2-4-4-stack-top" /></p>

<p>The program will pop the string address and save to <code class="language-plaintext highlighter-rouge">esi</code> register after the instruction <code class="language-plaintext highlighter-rouge">pop esi</code>. <code class="language-plaintext highlighter-rouge">esi</code> register now holds the address of the string.</p>

<p><img src="/assets/screenshots/2-4-5-esi-holds-string-addr.png" alt="2-4-5-esi-holds-string-addr" /></p>

<p>Then, the program copys the string address to <code class="language-plaintext highlighter-rouge">ebx</code> register, ready to be used as first argument of <code class="language-plaintext highlighter-rouge">execve </code> system call.</p>

<p>The first 7 characters in the string contains the filename of the shell program we want to run in the shellcode. To construct the filename string, the program rewrites the memory at <code class="language-plaintext highlighter-rouge">[ebx+7]</code> with <code class="language-plaintext highlighter-rouge">\0</code> to terminate the filename string.</p>

<p><img src="/assets/screenshots/2-4-6-turncate-string.png" alt="2-4-6-turncate-string" /></p>

<p>Next, the program saves the address of string <code class="language-plaintext highlighter-rouge">/bin/sh</code> to the memory at <code class="language-plaintext highlighter-rouge">[ebx+8]</code>, ready to construct the <code class="language-plaintext highlighter-rouge">argv</code> array.</p>

<p><img src="/assets/screenshots/2-4-7-argv.png" alt="2-4-7-argv" /></p>

<p>The program terminate the <code class="language-plaintext highlighter-rouge">argv</code> array with <code class="language-plaintext highlighter-rouge">0</code> at <code class="language-plaintext highlighter-rouge">[ebx+12]</code> and assigns the <code class="language-plaintext highlighter-rouge">ecx</code> register with the <code class="language-plaintext highlighter-rouge">argv</code> array.</p>

<p><img src="/assets/screenshots/2-4-8-argv-array.png" alt="2-4-8-argv-array" /></p>

<p>The program save <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">edx</code> for no environment variable is passed to the shell program.</p>

<p><img src="/assets/screenshots/2-4-9-no-envp.png" alt="2-4-9-no-envp" /></p>

<p>In the last, the program save <code class="language-plaintext highlighter-rouge">0x0b</code> to <code class="language-plaintext highlighter-rouge">eax</code> and invokes a system call interrupt to spawn a shell.</p>

<p><img src="/assets/screenshots/2-4-10-sh.png" alt="2-4-10-sh" /></p>

<p><code class="language-plaintext highlighter-rouge">src/task2/labsh_rel.asm</code></p>

<pre><code class="language-assembly">section .text
global _start
_start:
      	jmp two
one:
				pop esi
        mov ebx, esi 						; (complete) ebx should contain the string address
				mov eax, 0
        mov byte [ebx+7], 0x00  ; (complete) terminate /bin/sh with 0x00 (1 byte)
        mov [ebx+8], ebx   			; (complete) save ebx to memory at addressebx+8, points to "/bin/sh" saved at $ebx
        mov [ebx+12], eax  			; (complete) save eax to memory at address ebx+12, terminates the argv[]
        lea ecx, [ebx+8]   			; let ecx = ebx + 8
        
				mov edx, 0
        mov al, 0x0b
        int 0x80
				;	execve("/bin/sh", ["/bin/sh"], NULL)
two:
        call one
        db "/bin/sh*AAAABBBB"		; "/bin/sh" and remaining characters as placeholder
</code></pre>

<p>Since this program is required for writable code segment, to produce a executable binary file for this program, we need to use the <code class="language-plaintext highlighter-rouge">--omagic</code> flag to enable <code class="language-plaintext highlighter-rouge">ld</code> to do so.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nasm <span class="nt">-f</span> elf32 ./src/task2/labsh.rel.asm
ld <span class="nt">--omagic</span> ./src/task2/labsh_rel.o <span class="nt">-o</span> labsh_rel
./labsh_rel
</code></pre></div></div>]]></content><author><name>Jianing</name></author><category term="binary" /><summary type="html"><![CDATA[1. Printing on the Screen]]></summary></entry></feed>